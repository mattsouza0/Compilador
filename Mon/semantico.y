/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the semantico_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE semantico__scan_string(const char *str, yyscan_t scanner);
extern void semantico__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void semantico_lex_destroy(yyscan_t scanner);
extern char* semantico_get_text(yyscan_t scanner);

extern yyscan_t semantico__initialize_lexer(FILE * inp);

/* List reversal functions. */

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Progr progr_;
  BlocoDec blocodec_;
  BlocoConstante blococonstante_;
  RegraConstante regraconstante_;
  RegraDec regradec_;
  BlocoVar blocovar_;
  RegraDecVar regradecvar_;
  BlocoType blocotype_;
  RegraType regratype_;
  RegraDecVetor regradecvetor_;
  RegraDecStruct regradecstruct_;
  BlocoStmt blocostmt_;
  RegraStmt regrastmt_;
  Stmt stmt_;
  Atribuicao atribuicao_;
  AtribuicaoVetor atribuicaovetor_;
  AtribuicaoStruct atribuicaostruct_;
  Valor valor_;
  RExpr rexpr_;
  Opa opa_;
  ExpressaoLogica expressaologica_;
  If if_;
  IfStmt ifstmt_;
  ElseStmt elsestmt_;
  ElsIfStmt elsifstmt_;
  While while_;
  For for_;
  Case case_;
  CaseStmt casestmt_;
  Type type_;
  OperadoresLogicos operadoreslogicos_;
  ConectivosLogicos conectivoslogicos_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, semantico_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _LPAREN       /* ( */
%token          _RPAREN       /* ) */
%token          _STAR         /* * */
%token          _PLUS         /* + */
%token          _MINUS        /* - */
%token          _DOT          /* . */
%token          _SLASH        /* / */
%token          _COLON        /* : */
%token          _COLONEQ      /* := */
%token          _SEMI         /* ; */
%token          _LT           /* < */
%token          _LDARROW      /* <= */
%token          _LTGT         /* <> */
%token          _EQ           /* = */
%token          _GT           /* > */
%token          _GTEQ         /* >= */
%token          _KW_AND       /* AND */
%token          _KW_BEGIN     /* BEGIN */
%token          _KW_CASE      /* CASE */
%token          _KW_CHAR      /* CHAR */
%token          _KW_CONST     /* CONST */
%token          _KW_DE        /* DE */
%token          _KW_DO        /* DO */
%token          _KW_ELSE      /* ELSE */
%token          _KW_ELSIF     /* ELSIF */
%token          _KW_END       /* END */
%token          _KW_FOR       /* FOR */
%token          _KW_IF        /* IF */
%token          _KW_INTEGER   /* INTEGER */
%token          _KW_MODULE    /* MODULE */
%token          _KW_NOT       /* NOT */
%token          _KW_OF        /* OF */
%token          _KW_OR        /* OR */
%token          _KW_REAL      /* REAL */
%token          _KW_REGISTRO  /* REGISTRO */
%token          _KW_STRING    /* STRING */
%token          _KW_THEN      /* THEN */
%token          _KW_TO        /* TO */
%token          _KW_TYPE      /* TYPE */
%token          _KW_VAR       /* VAR */
%token          _KW_VETOR     /* VETOR */
%token          _KW_WHILE     /* WHILE */
%token          _LBRACK       /* [ */
%token          _RBRACK       /* ] */
%token<_string> _STRING_
%token<_char>   _CHAR_
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%type <progr_> Progr
%type <blocodec_> BlocoDec
%type <blococonstante_> BlocoConstante
%type <regraconstante_> RegraConstante
%type <regradec_> RegraDec
%type <blocovar_> BlocoVar
%type <regradecvar_> RegraDecVar
%type <blocotype_> BlocoType
%type <regratype_> RegraType
%type <regradecvetor_> RegraDecVetor
%type <regradecstruct_> RegraDecStruct
%type <blocostmt_> BlocoStmt
%type <regrastmt_> RegraStmt
%type <stmt_> Stmt
%type <atribuicao_> Atribuicao
%type <atribuicaovetor_> AtribuicaoVetor
%type <atribuicaostruct_> AtribuicaoStruct
%type <valor_> Valor
%type <rexpr_> RExpr
%type <opa_> Opa
%type <opa_> Opa1
%type <opa_> Opa2
%type <expressaologica_> ExpressaoLogica
%type <if_> If
%type <ifstmt_> IfStmt
%type <elsestmt_> ElseStmt
%type <elsifstmt_> ElsIfStmt
%type <while_> While
%type <for_> For
%type <case_> Case
%type <casestmt_> CaseStmt
%type <type_> Type
%type <operadoreslogicos_> OperadoresLogicos
%type <conectivoslogicos_> ConectivosLogicos

%start Progr

%%

Progr : _KW_MODULE _IDENT_ _SEMI BlocoDec _KW_BEGIN RegraStmt _KW_END _IDENT_ _DOT { $$ = make_Program($2, $4, $6, $8); result->progr_ = $$; }
;
BlocoDec : BlocoConstante BlocoDec { $$ = make_BlocoDec1($1, $2); result->blocodec_ = $$; }
  | BlocoVar BlocoDec { $$ = make_BlocoDec2($1, $2); result->blocodec_ = $$; }
  | BlocoType BlocoDec { $$ = make_BlocoDec3($1, $2); result->blocodec_ = $$; }
  | /* empty */ { $$ = make_BlocoDec_(); result->blocodec_ = $$; }
;
BlocoConstante : _KW_CONST RegraConstante { $$ = make_BlocoConstante1($2); result->blococonstante_ = $$; }
;
RegraConstante : _IDENT_ _COLON Type _EQ Valor _SEMI { $$ = make_RegraConstante1($1, $3, $5); result->regraconstante_ = $$; }
  | _IDENT_ _COLON Type _EQ Valor _SEMI RegraConstante { $$ = make_RegraConstante2($1, $3, $5, $7); result->regraconstante_ = $$; }
;
RegraDec : _IDENT_ _COLON Type { $$ = make_RegraDec1($1, $3); result->regradec_ = $$; }
  | _IDENT_ _COLON Type RegraDec { $$ = make_RegraDec2($1, $3, $4); result->regradec_ = $$; }
;
BlocoVar : _KW_VAR RegraDecVar { $$ = make_BlocoVar1($2); result->blocovar_ = $$; }
;
RegraDecVar : RegraDec _SEMI { $$ = make_RegraDecVar1($1); result->regradecvar_ = $$; }
  | RegraDec _SEMI RegraDecVar { $$ = make_RegraDecVar2($1, $3); result->regradecvar_ = $$; }
;
BlocoType : _KW_TYPE RegraType { $$ = make_BlocoType1($2); result->blocotype_ = $$; }
;
RegraType : RegraDecVetor { $$ = make_RegraTypeRegraDecVetor($1); result->regratype_ = $$; }
  | RegraDecVetor RegraType { $$ = make_RegraType1($1, $2); result->regratype_ = $$; }
  | RegraDecStruct { $$ = make_RegraTypeRegraDecStruct($1); result->regratype_ = $$; }
  | RegraDecStruct RegraType { $$ = make_RegraType2($1, $2); result->regratype_ = $$; }
;
RegraDecVetor : _IDENT_ _EQ _KW_VETOR _INTEGER_ _KW_DE Type _SEMI { $$ = make_RegraDecVetor1($1, $4, $6); result->regradecvetor_ = $$; }
;
RegraDecStruct : _IDENT_ _EQ _KW_REGISTRO _KW_DE RegraDec _KW_END { $$ = make_RegraDecStruct1($1, $5); result->regradecstruct_ = $$; }
  | _IDENT_ _EQ _KW_REGISTRO _KW_DE RegraDec _KW_END RegraDecStruct { $$ = make_RegraDecStruct2($1, $5, $7); result->regradecstruct_ = $$; }
;
BlocoStmt : _KW_BEGIN RegraStmt _KW_END { $$ = make_BlocoStmt1($2); result->blocostmt_ = $$; }
;
RegraStmt : Stmt { $$ = make_RegraStmtStmt($1); result->regrastmt_ = $$; }
  | Stmt RegraStmt { $$ = make_RegraStmt1($1, $2); result->regrastmt_ = $$; }
  | /* empty */ { $$ = make_RegraStmt_(); result->regrastmt_ = $$; }
;
Stmt : Atribuicao _SEMI { $$ = make_Stmt1($1); result->stmt_ = $$; }
  | Opa _SEMI { $$ = make_Stmt2($1); result->stmt_ = $$; }
  | If _SEMI { $$ = make_Stmt3($1); result->stmt_ = $$; }
  | While _SEMI { $$ = make_Stmt4($1); result->stmt_ = $$; }
  | For _SEMI { $$ = make_Stmt5($1); result->stmt_ = $$; }
  | Case _SEMI { $$ = make_Stmt6($1); result->stmt_ = $$; }
;
Atribuicao : _IDENT_ _COLONEQ RExpr { $$ = make_Atribuicao1($1, $3); result->atribuicao_ = $$; }
  | AtribuicaoVetor { $$ = make_AtribuicaoAtribuicaoVetor($1); result->atribuicao_ = $$; }
  | AtribuicaoStruct { $$ = make_AtribuicaoAtribuicaoStruct($1); result->atribuicao_ = $$; }
;
AtribuicaoVetor : _IDENT_ _LBRACK _INTEGER_ _RBRACK _COLONEQ Valor { $$ = make_AtribuicaoVetor1($1, $3, $6); result->atribuicaovetor_ = $$; }
  | _IDENT_ _LBRACK _INTEGER_ _RBRACK _COLONEQ _IDENT_ { $$ = make_AtribuicaoVetor2($1, $3, $6); result->atribuicaovetor_ = $$; }
;
AtribuicaoStruct : _IDENT_ _DOT _IDENT_ _COLONEQ Valor { $$ = make_AtribuicaoStruct1($1, $3, $5); result->atribuicaostruct_ = $$; }
  | _IDENT_ _DOT _IDENT_ _COLONEQ _IDENT_ { $$ = make_AtribuicaoStruct2($1, $3, $5); result->atribuicaostruct_ = $$; }
;
Valor : _STRING_ { $$ = make_ValorString($1); result->valor_ = $$; }
  | _CHAR_ { $$ = make_ValorChar($1); result->valor_ = $$; }
  | _DOUBLE_ { $$ = make_ValorDouble($1); result->valor_ = $$; }
  | _INTEGER_ { $$ = make_ValorInteger($1); result->valor_ = $$; }
;
RExpr : Valor { $$ = make_RExprValor($1); result->rexpr_ = $$; }
  | _IDENT_ { $$ = make_RExprIdent($1); result->rexpr_ = $$; }
  | Opa { $$ = make_RExprOpa($1); result->rexpr_ = $$; }
;
Opa : Opa _PLUS Opa1 { $$ = make_LSom($1, $3); result->opa_ = $$; }
  | Opa _MINUS Opa1 { $$ = make_LSub($1, $3); result->opa_ = $$; }
  | Opa1 { $$ = $1; result->opa_ = $$; }
;
Opa1 : Opa1 _STAR Opa2 { $$ = make_LMul($1, $3); result->opa_ = $$; }
  | Opa1 _SLASH Opa2 { $$ = make_LDiv($1, $3); result->opa_ = $$; }
  | Opa2 { $$ = $1; result->opa_ = $$; }
;
Opa2 : _INTEGER_ { $$ = make_Opa2Integer($1); result->opa_ = $$; }
  | _DOUBLE_ { $$ = make_Opa2Double($1); result->opa_ = $$; }
  | _IDENT_ { $$ = make_Opa2Ident($1); result->opa_ = $$; }
  | _LPAREN Opa _RPAREN { $$ = $2; result->opa_ = $$; }
;
ExpressaoLogica : RExpr OperadoresLogicos RExpr { $$ = make_ExpressaoLogica1($1, $2, $3); result->expressaologica_ = $$; }
  | RExpr OperadoresLogicos RExpr ConectivosLogicos ExpressaoLogica { $$ = make_ExpressaoLogica2($1, $2, $3, $4, $5); result->expressaologica_ = $$; }
;
If : IfStmt { $$ = make_IfIfStmt($1); result->if_ = $$; }
  | IfStmt ElseStmt { $$ = make_If1($1, $2); result->if_ = $$; }
  | IfStmt ElsIfStmt ElseStmt { $$ = make_If2($1, $2, $3); result->if_ = $$; }
  | /* empty */ { $$ = make_If_(); result->if_ = $$; }
;
IfStmt : _KW_IF ExpressaoLogica _KW_THEN BlocoStmt { $$ = make_IfStmt1($2, $4); result->ifstmt_ = $$; }
;
ElseStmt : _KW_ELSE BlocoStmt { $$ = make_ElseStmt1($2); result->elsestmt_ = $$; }
;
ElsIfStmt : _KW_ELSIF ExpressaoLogica _KW_THEN BlocoStmt { $$ = make_ElsIfStmt1($2, $4); result->elsifstmt_ = $$; }
;
While : _KW_WHILE ExpressaoLogica _KW_DO BlocoStmt { $$ = make_While1($2, $4); result->while_ = $$; }
;
For : _KW_FOR Atribuicao _KW_TO RExpr _KW_DO BlocoStmt { $$ = make_For1($2, $4, $6); result->for_ = $$; }
;
Case : CaseStmt { $$ = make_CaseCaseStmt($1); result->case_ = $$; }
;
CaseStmt : _KW_CASE _IDENT_ _KW_OF BlocoStmt { $$ = make_CaseStmt1($2, $4); result->casestmt_ = $$; }
  | _KW_ELSE BlocoStmt { $$ = make_CaseStmt2($2); result->casestmt_ = $$; }
;
Type : _KW_INTEGER { $$ = make_Type_INTEGER(); result->type_ = $$; }
  | _KW_REAL { $$ = make_Type_REAL(); result->type_ = $$; }
  | _KW_CHAR { $$ = make_Type_CHAR(); result->type_ = $$; }
  | _KW_STRING { $$ = make_Type_STRING(); result->type_ = $$; }
;
OperadoresLogicos : _GT { $$ = make_OperadoresLogicos1(); result->operadoreslogicos_ = $$; }
  | _LT { $$ = make_OperadoresLogicos2(); result->operadoreslogicos_ = $$; }
  | _GTEQ { $$ = make_OperadoresLogicos3(); result->operadoreslogicos_ = $$; }
  | _LDARROW { $$ = make_OperadoresLogicos4(); result->operadoreslogicos_ = $$; }
  | _EQ { $$ = make_OperadoresLogicos5(); result->operadoreslogicos_ = $$; }
  | _LTGT { $$ = make_OperadoresLogicos6(); result->operadoreslogicos_ = $$; }
;
ConectivosLogicos : _KW_AND { $$ = make_ConectivosLogicos_AND(); result->conectivoslogicos_ = $$; }
  | _KW_OR { $$ = make_ConectivosLogicos_OR(); result->conectivoslogicos_ = $$; }
  | _KW_NOT { $$ = make_ConectivosLogicos_NOT(); result->conectivoslogicos_ = $$; }
;

%%


/* Entrypoint: parse Progr from file. */
Progr pProgr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.progr_;
  }
}

/* Entrypoint: parse Progr from string. */
Progr psProgr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.progr_;
  }
}

/* Entrypoint: parse BlocoDec from file. */
BlocoDec pBlocoDec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocodec_;
  }
}

/* Entrypoint: parse BlocoDec from string. */
BlocoDec psBlocoDec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocodec_;
  }
}

/* Entrypoint: parse BlocoConstante from file. */
BlocoConstante pBlocoConstante(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blococonstante_;
  }
}

/* Entrypoint: parse BlocoConstante from string. */
BlocoConstante psBlocoConstante(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blococonstante_;
  }
}

/* Entrypoint: parse RegraConstante from file. */
RegraConstante pRegraConstante(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regraconstante_;
  }
}

/* Entrypoint: parse RegraConstante from string. */
RegraConstante psRegraConstante(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regraconstante_;
  }
}

/* Entrypoint: parse RegraDec from file. */
RegraDec pRegraDec(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regradec_;
  }
}

/* Entrypoint: parse RegraDec from string. */
RegraDec psRegraDec(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regradec_;
  }
}

/* Entrypoint: parse BlocoVar from file. */
BlocoVar pBlocoVar(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocovar_;
  }
}

/* Entrypoint: parse BlocoVar from string. */
BlocoVar psBlocoVar(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocovar_;
  }
}

/* Entrypoint: parse RegraDecVar from file. */
RegraDecVar pRegraDecVar(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regradecvar_;
  }
}

/* Entrypoint: parse RegraDecVar from string. */
RegraDecVar psRegraDecVar(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regradecvar_;
  }
}

/* Entrypoint: parse BlocoType from file. */
BlocoType pBlocoType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocotype_;
  }
}

/* Entrypoint: parse BlocoType from string. */
BlocoType psBlocoType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocotype_;
  }
}

/* Entrypoint: parse RegraType from file. */
RegraType pRegraType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regratype_;
  }
}

/* Entrypoint: parse RegraType from string. */
RegraType psRegraType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regratype_;
  }
}

/* Entrypoint: parse RegraDecVetor from file. */
RegraDecVetor pRegraDecVetor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regradecvetor_;
  }
}

/* Entrypoint: parse RegraDecVetor from string. */
RegraDecVetor psRegraDecVetor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regradecvetor_;
  }
}

/* Entrypoint: parse RegraDecStruct from file. */
RegraDecStruct pRegraDecStruct(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regradecstruct_;
  }
}

/* Entrypoint: parse RegraDecStruct from string. */
RegraDecStruct psRegraDecStruct(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regradecstruct_;
  }
}

/* Entrypoint: parse BlocoStmt from file. */
BlocoStmt pBlocoStmt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocostmt_;
  }
}

/* Entrypoint: parse BlocoStmt from string. */
BlocoStmt psBlocoStmt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocostmt_;
  }
}

/* Entrypoint: parse RegraStmt from file. */
RegraStmt pRegraStmt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrastmt_;
  }
}

/* Entrypoint: parse RegraStmt from string. */
RegraStmt psRegraStmt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrastmt_;
  }
}

/* Entrypoint: parse Stmt from file. */
Stmt pStmt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.stmt_;
  }
}

/* Entrypoint: parse Stmt from string. */
Stmt psStmt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.stmt_;
  }
}

/* Entrypoint: parse Atribuicao from file. */
Atribuicao pAtribuicao(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicao_;
  }
}

/* Entrypoint: parse Atribuicao from string. */
Atribuicao psAtribuicao(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicao_;
  }
}

/* Entrypoint: parse AtribuicaoVetor from file. */
AtribuicaoVetor pAtribuicaoVetor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicaovetor_;
  }
}

/* Entrypoint: parse AtribuicaoVetor from string. */
AtribuicaoVetor psAtribuicaoVetor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicaovetor_;
  }
}

/* Entrypoint: parse AtribuicaoStruct from file. */
AtribuicaoStruct pAtribuicaoStruct(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicaostruct_;
  }
}

/* Entrypoint: parse AtribuicaoStruct from string. */
AtribuicaoStruct psAtribuicaoStruct(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicaostruct_;
  }
}

/* Entrypoint: parse Valor from file. */
Valor pValor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.valor_;
  }
}

/* Entrypoint: parse Valor from string. */
Valor psValor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.valor_;
  }
}

/* Entrypoint: parse RExpr from file. */
RExpr pRExpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.rexpr_;
  }
}

/* Entrypoint: parse RExpr from string. */
RExpr psRExpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.rexpr_;
  }
}

/* Entrypoint: parse Opa from file. */
Opa pOpa(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opa_;
  }
}

/* Entrypoint: parse Opa from string. */
Opa psOpa(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opa_;
  }
}

/* Entrypoint: parse Opa from file. */
Opa pOpa1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opa_;
  }
}

/* Entrypoint: parse Opa from string. */
Opa psOpa1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opa_;
  }
}

/* Entrypoint: parse Opa from file. */
Opa pOpa2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opa_;
  }
}

/* Entrypoint: parse Opa from string. */
Opa psOpa2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opa_;
  }
}

/* Entrypoint: parse ExpressaoLogica from file. */
ExpressaoLogica pExpressaoLogica(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaologica_;
  }
}

/* Entrypoint: parse ExpressaoLogica from string. */
ExpressaoLogica psExpressaoLogica(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaologica_;
  }
}

/* Entrypoint: parse If from file. */
If pIf(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.if_;
  }
}

/* Entrypoint: parse If from string. */
If psIf(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.if_;
  }
}

/* Entrypoint: parse IfStmt from file. */
IfStmt pIfStmt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ifstmt_;
  }
}

/* Entrypoint: parse IfStmt from string. */
IfStmt psIfStmt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ifstmt_;
  }
}

/* Entrypoint: parse ElseStmt from file. */
ElseStmt pElseStmt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.elsestmt_;
  }
}

/* Entrypoint: parse ElseStmt from string. */
ElseStmt psElseStmt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.elsestmt_;
  }
}

/* Entrypoint: parse ElsIfStmt from file. */
ElsIfStmt pElsIfStmt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.elsifstmt_;
  }
}

/* Entrypoint: parse ElsIfStmt from string. */
ElsIfStmt psElsIfStmt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.elsifstmt_;
  }
}

/* Entrypoint: parse While from file. */
While pWhile(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.while_;
  }
}

/* Entrypoint: parse While from string. */
While psWhile(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.while_;
  }
}

/* Entrypoint: parse For from file. */
For pFor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.for_;
  }
}

/* Entrypoint: parse For from string. */
For psFor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.for_;
  }
}

/* Entrypoint: parse Case from file. */
Case pCase(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.case_;
  }
}

/* Entrypoint: parse Case from string. */
Case psCase(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.case_;
  }
}

/* Entrypoint: parse CaseStmt from file. */
CaseStmt pCaseStmt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.casestmt_;
  }
}

/* Entrypoint: parse CaseStmt from string. */
CaseStmt psCaseStmt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.casestmt_;
  }
}

/* Entrypoint: parse Type from file. */
Type pType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type from string. */
Type psType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse OperadoresLogicos from file. */
OperadoresLogicos pOperadoresLogicos(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadoreslogicos_;
  }
}

/* Entrypoint: parse OperadoresLogicos from string. */
OperadoresLogicos psOperadoresLogicos(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadoreslogicos_;
  }
}

/* Entrypoint: parse ConectivosLogicos from file. */
ConectivosLogicos pConectivosLogicos(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.conectivoslogicos_;
  }
}

/* Entrypoint: parse ConectivosLogicos from string. */
ConectivosLogicos psConectivosLogicos(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = semantico__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = semantico__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  semantico__delete_buffer(buf, scanner);
  semantico_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.conectivoslogicos_;
  }
}



