/* File generated by the BNF Converter (bnfc 2.9.4). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   Program    ********************/

Progr make_Program(Ident p1, BlocoDec p2, RegraStmt p3, Ident p4)
{
    Progr tmp = (Progr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Program!\n");
        exit(1);
    }
    tmp->kind = is_Program;
    tmp->u.program_.ident_1 = p1;
    tmp->u.program_.blocodec_ = p2;
    tmp->u.program_.regrastmt_ = p3;
    tmp->u.program_.ident_2 = p4;
    return tmp;
}

/********************   BlocoDec1    ********************/

BlocoDec make_BlocoDec1(BlocoConstante p1, BlocoDec p2)
{
    BlocoDec tmp = (BlocoDec) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoDec1!\n");
        exit(1);
    }
    tmp->kind = is_BlocoDec1;
    tmp->u.blocodec1_.blococonstante_ = p1;
    tmp->u.blocodec1_.blocodec_ = p2;
    return tmp;
}

/********************   BlocoDec2    ********************/

BlocoDec make_BlocoDec2(BlocoVar p1, BlocoDec p2)
{
    BlocoDec tmp = (BlocoDec) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoDec2!\n");
        exit(1);
    }
    tmp->kind = is_BlocoDec2;
    tmp->u.blocodec2_.blocovar_ = p1;
    tmp->u.blocodec2_.blocodec_ = p2;
    return tmp;
}

/********************   BlocoDec3    ********************/

BlocoDec make_BlocoDec3(BlocoType p1, BlocoDec p2)
{
    BlocoDec tmp = (BlocoDec) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoDec3!\n");
        exit(1);
    }
    tmp->kind = is_BlocoDec3;
    tmp->u.blocodec3_.blocotype_ = p1;
    tmp->u.blocodec3_.blocodec_ = p2;
    return tmp;
}

/********************   BlocoDec_    ********************/

BlocoDec make_BlocoDec_()
{
    BlocoDec tmp = (BlocoDec) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoDec_!\n");
        exit(1);
    }
    tmp->kind = is_BlocoDec_;
    return tmp;
}

/********************   BlocoConstante1    ********************/

BlocoConstante make_BlocoConstante1(RegraConstante p1)
{
    BlocoConstante tmp = (BlocoConstante) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoConstante1!\n");
        exit(1);
    }
    tmp->kind = is_BlocoConstante1;
    tmp->u.blococonstante1_.regraconstante_ = p1;
    return tmp;
}

/********************   RegraConstante1    ********************/

RegraConstante make_RegraConstante1(Ident p1, Type p2, Valor p3)
{
    RegraConstante tmp = (RegraConstante) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraConstante1!\n");
        exit(1);
    }
    tmp->kind = is_RegraConstante1;
    tmp->u.regraconstante1_.ident_ = p1;
    tmp->u.regraconstante1_.type_ = p2;
    tmp->u.regraconstante1_.valor_ = p3;
    return tmp;
}

/********************   RegraConstante2    ********************/

RegraConstante make_RegraConstante2(Ident p1, Type p2, Valor p3, RegraConstante p4)
{
    RegraConstante tmp = (RegraConstante) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraConstante2!\n");
        exit(1);
    }
    tmp->kind = is_RegraConstante2;
    tmp->u.regraconstante2_.ident_ = p1;
    tmp->u.regraconstante2_.type_ = p2;
    tmp->u.regraconstante2_.valor_ = p3;
    tmp->u.regraconstante2_.regraconstante_ = p4;
    return tmp;
}

/********************   RegraDec1    ********************/

RegraDec make_RegraDec1(Ident p1, Type p2)
{
    RegraDec tmp = (RegraDec) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraDec1!\n");
        exit(1);
    }
    tmp->kind = is_RegraDec1;
    tmp->u.regradec1_.ident_ = p1;
    tmp->u.regradec1_.type_ = p2;
    return tmp;
}

/********************   RegraDec2    ********************/

RegraDec make_RegraDec2(Ident p1, Type p2, RegraDec p3)
{
    RegraDec tmp = (RegraDec) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraDec2!\n");
        exit(1);
    }
    tmp->kind = is_RegraDec2;
    tmp->u.regradec2_.ident_ = p1;
    tmp->u.regradec2_.type_ = p2;
    tmp->u.regradec2_.regradec_ = p3;
    return tmp;
}

/********************   BlocoVar1    ********************/

BlocoVar make_BlocoVar1(RegraDecVar p1)
{
    BlocoVar tmp = (BlocoVar) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoVar1!\n");
        exit(1);
    }
    tmp->kind = is_BlocoVar1;
    tmp->u.blocovar1_.regradecvar_ = p1;
    return tmp;
}

/********************   RegraDecVar1    ********************/

RegraDecVar make_RegraDecVar1(RegraDec p1)
{
    RegraDecVar tmp = (RegraDecVar) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraDecVar1!\n");
        exit(1);
    }
    tmp->kind = is_RegraDecVar1;
    tmp->u.regradecvar1_.regradec_ = p1;
    return tmp;
}

/********************   RegraDecVar2    ********************/

RegraDecVar make_RegraDecVar2(RegraDec p1, RegraDecVar p2)
{
    RegraDecVar tmp = (RegraDecVar) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraDecVar2!\n");
        exit(1);
    }
    tmp->kind = is_RegraDecVar2;
    tmp->u.regradecvar2_.regradec_ = p1;
    tmp->u.regradecvar2_.regradecvar_ = p2;
    return tmp;
}

/********************   BlocoType1    ********************/

BlocoType make_BlocoType1(RegraType p1)
{
    BlocoType tmp = (BlocoType) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoType1!\n");
        exit(1);
    }
    tmp->kind = is_BlocoType1;
    tmp->u.blocotype1_.regratype_ = p1;
    return tmp;
}

/********************   RegraTypeRegraDecVetor    ********************/

RegraType make_RegraTypeRegraDecVetor(RegraDecVetor p1)
{
    RegraType tmp = (RegraType) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraTypeRegraDecVetor!\n");
        exit(1);
    }
    tmp->kind = is_RegraTypeRegraDecVetor;
    tmp->u.regratyperegradecvetor_.regradecvetor_ = p1;
    return tmp;
}

/********************   RegraType1    ********************/

RegraType make_RegraType1(RegraDecVetor p1, RegraType p2)
{
    RegraType tmp = (RegraType) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraType1!\n");
        exit(1);
    }
    tmp->kind = is_RegraType1;
    tmp->u.regratype1_.regradecvetor_ = p1;
    tmp->u.regratype1_.regratype_ = p2;
    return tmp;
}

/********************   RegraTypeRegraDecStruct    ********************/

RegraType make_RegraTypeRegraDecStruct(RegraDecStruct p1)
{
    RegraType tmp = (RegraType) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraTypeRegraDecStruct!\n");
        exit(1);
    }
    tmp->kind = is_RegraTypeRegraDecStruct;
    tmp->u.regratyperegradecstruct_.regradecstruct_ = p1;
    return tmp;
}

/********************   RegraType2    ********************/

RegraType make_RegraType2(RegraDecStruct p1, RegraType p2)
{
    RegraType tmp = (RegraType) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraType2!\n");
        exit(1);
    }
    tmp->kind = is_RegraType2;
    tmp->u.regratype2_.regradecstruct_ = p1;
    tmp->u.regratype2_.regratype_ = p2;
    return tmp;
}

/********************   RegraDecVetor1    ********************/

RegraDecVetor make_RegraDecVetor1(Ident p1, Integer p2, Type p3)
{
    RegraDecVetor tmp = (RegraDecVetor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraDecVetor1!\n");
        exit(1);
    }
    tmp->kind = is_RegraDecVetor1;
    tmp->u.regradecvetor1_.ident_ = p1;
    tmp->u.regradecvetor1_.integer_ = p2;
    tmp->u.regradecvetor1_.type_ = p3;
    return tmp;
}

/********************   RegraDecStruct1    ********************/

RegraDecStruct make_RegraDecStruct1(Ident p1, RegraDec p2)
{
    RegraDecStruct tmp = (RegraDecStruct) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraDecStruct1!\n");
        exit(1);
    }
    tmp->kind = is_RegraDecStruct1;
    tmp->u.regradecstruct1_.ident_ = p1;
    tmp->u.regradecstruct1_.regradec_ = p2;
    return tmp;
}

/********************   RegraDecStruct2    ********************/

RegraDecStruct make_RegraDecStruct2(Ident p1, RegraDec p2, RegraDecStruct p3)
{
    RegraDecStruct tmp = (RegraDecStruct) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraDecStruct2!\n");
        exit(1);
    }
    tmp->kind = is_RegraDecStruct2;
    tmp->u.regradecstruct2_.ident_ = p1;
    tmp->u.regradecstruct2_.regradec_ = p2;
    tmp->u.regradecstruct2_.regradecstruct_ = p3;
    return tmp;
}

/********************   BlocoStmt1    ********************/

BlocoStmt make_BlocoStmt1(RegraStmt p1)
{
    BlocoStmt tmp = (BlocoStmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoStmt1!\n");
        exit(1);
    }
    tmp->kind = is_BlocoStmt1;
    tmp->u.blocostmt1_.regrastmt_ = p1;
    return tmp;
}

/********************   RegraStmtStmt    ********************/

RegraStmt make_RegraStmtStmt(Stmt p1)
{
    RegraStmt tmp = (RegraStmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraStmtStmt!\n");
        exit(1);
    }
    tmp->kind = is_RegraStmtStmt;
    tmp->u.regrastmtstmt_.stmt_ = p1;
    return tmp;
}

/********************   RegraStmt1    ********************/

RegraStmt make_RegraStmt1(Stmt p1, RegraStmt p2)
{
    RegraStmt tmp = (RegraStmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraStmt1!\n");
        exit(1);
    }
    tmp->kind = is_RegraStmt1;
    tmp->u.regrastmt1_.stmt_ = p1;
    tmp->u.regrastmt1_.regrastmt_ = p2;
    return tmp;
}

/********************   RegraStmt_    ********************/

RegraStmt make_RegraStmt_()
{
    RegraStmt tmp = (RegraStmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraStmt_!\n");
        exit(1);
    }
    tmp->kind = is_RegraStmt_;
    return tmp;
}

/********************   Stmt1    ********************/

Stmt make_Stmt1(Atribuicao p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stmt1!\n");
        exit(1);
    }
    tmp->kind = is_Stmt1;
    tmp->u.stmt1_.atribuicao_ = p1;
    return tmp;
}

/********************   Stmt2    ********************/

Stmt make_Stmt2(Opa p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stmt2!\n");
        exit(1);
    }
    tmp->kind = is_Stmt2;
    tmp->u.stmt2_.opa_ = p1;
    return tmp;
}

/********************   Stmt3    ********************/

Stmt make_Stmt3(If p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stmt3!\n");
        exit(1);
    }
    tmp->kind = is_Stmt3;
    tmp->u.stmt3_.if_ = p1;
    return tmp;
}

/********************   Stmt4    ********************/

Stmt make_Stmt4(While p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stmt4!\n");
        exit(1);
    }
    tmp->kind = is_Stmt4;
    tmp->u.stmt4_.while_ = p1;
    return tmp;
}

/********************   Stmt5    ********************/

Stmt make_Stmt5(For p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stmt5!\n");
        exit(1);
    }
    tmp->kind = is_Stmt5;
    tmp->u.stmt5_.for_ = p1;
    return tmp;
}

/********************   Stmt6    ********************/

Stmt make_Stmt6(Case p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stmt6!\n");
        exit(1);
    }
    tmp->kind = is_Stmt6;
    tmp->u.stmt6_.case_ = p1;
    return tmp;
}

/********************   Atribuicao1    ********************/

Atribuicao make_Atribuicao1(Ident p1, RExpr p2)
{
    Atribuicao tmp = (Atribuicao) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Atribuicao1!\n");
        exit(1);
    }
    tmp->kind = is_Atribuicao1;
    tmp->u.atribuicao1_.ident_ = p1;
    tmp->u.atribuicao1_.rexpr_ = p2;
    return tmp;
}

/********************   AtribuicaoAtribuicaoVetor    ********************/

Atribuicao make_AtribuicaoAtribuicaoVetor(AtribuicaoVetor p1)
{
    Atribuicao tmp = (Atribuicao) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AtribuicaoAtribuicaoVetor!\n");
        exit(1);
    }
    tmp->kind = is_AtribuicaoAtribuicaoVetor;
    tmp->u.atribuicaoatribuicaovetor_.atribuicaovetor_ = p1;
    return tmp;
}

/********************   AtribuicaoAtribuicaoStruct    ********************/

Atribuicao make_AtribuicaoAtribuicaoStruct(AtribuicaoStruct p1)
{
    Atribuicao tmp = (Atribuicao) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AtribuicaoAtribuicaoStruct!\n");
        exit(1);
    }
    tmp->kind = is_AtribuicaoAtribuicaoStruct;
    tmp->u.atribuicaoatribuicaostruct_.atribuicaostruct_ = p1;
    return tmp;
}

/********************   AtribuicaoVetor1    ********************/

AtribuicaoVetor make_AtribuicaoVetor1(Ident p1, Integer p2, Valor p3)
{
    AtribuicaoVetor tmp = (AtribuicaoVetor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AtribuicaoVetor1!\n");
        exit(1);
    }
    tmp->kind = is_AtribuicaoVetor1;
    tmp->u.atribuicaovetor1_.ident_ = p1;
    tmp->u.atribuicaovetor1_.integer_ = p2;
    tmp->u.atribuicaovetor1_.valor_ = p3;
    return tmp;
}

/********************   AtribuicaoVetor2    ********************/

AtribuicaoVetor make_AtribuicaoVetor2(Ident p1, Integer p2, Ident p3)
{
    AtribuicaoVetor tmp = (AtribuicaoVetor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AtribuicaoVetor2!\n");
        exit(1);
    }
    tmp->kind = is_AtribuicaoVetor2;
    tmp->u.atribuicaovetor2_.ident_1 = p1;
    tmp->u.atribuicaovetor2_.integer_ = p2;
    tmp->u.atribuicaovetor2_.ident_2 = p3;
    return tmp;
}

/********************   AtribuicaoStruct1    ********************/

AtribuicaoStruct make_AtribuicaoStruct1(Ident p1, Ident p2, Valor p3)
{
    AtribuicaoStruct tmp = (AtribuicaoStruct) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AtribuicaoStruct1!\n");
        exit(1);
    }
    tmp->kind = is_AtribuicaoStruct1;
    tmp->u.atribuicaostruct1_.ident_1 = p1;
    tmp->u.atribuicaostruct1_.ident_2 = p2;
    tmp->u.atribuicaostruct1_.valor_ = p3;
    return tmp;
}

/********************   AtribuicaoStruct2    ********************/

AtribuicaoStruct make_AtribuicaoStruct2(Ident p1, Ident p2, Ident p3)
{
    AtribuicaoStruct tmp = (AtribuicaoStruct) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AtribuicaoStruct2!\n");
        exit(1);
    }
    tmp->kind = is_AtribuicaoStruct2;
    tmp->u.atribuicaostruct2_.ident_1 = p1;
    tmp->u.atribuicaostruct2_.ident_2 = p2;
    tmp->u.atribuicaostruct2_.ident_3 = p3;
    return tmp;
}

/********************   ValorString    ********************/

Valor make_ValorString(String p1)
{
    Valor tmp = (Valor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValorString!\n");
        exit(1);
    }
    tmp->kind = is_ValorString;
    tmp->u.valorstring_.string_ = p1;
    return tmp;
}

/********************   ValorChar    ********************/

Valor make_ValorChar(Char p1)
{
    Valor tmp = (Valor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValorChar!\n");
        exit(1);
    }
    tmp->kind = is_ValorChar;
    tmp->u.valorchar_.char_ = p1;
    return tmp;
}

/********************   ValorDouble    ********************/

Valor make_ValorDouble(Double p1)
{
    Valor tmp = (Valor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValorDouble!\n");
        exit(1);
    }
    tmp->kind = is_ValorDouble;
    tmp->u.valordouble_.double_ = p1;
    return tmp;
}

/********************   ValorInteger    ********************/

Valor make_ValorInteger(Integer p1)
{
    Valor tmp = (Valor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValorInteger!\n");
        exit(1);
    }
    tmp->kind = is_ValorInteger;
    tmp->u.valorinteger_.integer_ = p1;
    return tmp;
}

/********************   RExprValor    ********************/

RExpr make_RExprValor(Valor p1)
{
    RExpr tmp = (RExpr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RExprValor!\n");
        exit(1);
    }
    tmp->kind = is_RExprValor;
    tmp->u.rexprvalor_.valor_ = p1;
    return tmp;
}

/********************   RExprIdent    ********************/

RExpr make_RExprIdent(Ident p1)
{
    RExpr tmp = (RExpr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RExprIdent!\n");
        exit(1);
    }
    tmp->kind = is_RExprIdent;
    tmp->u.rexprident_.ident_ = p1;
    return tmp;
}

/********************   RExprOpa    ********************/

RExpr make_RExprOpa(Opa p1)
{
    RExpr tmp = (RExpr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RExprOpa!\n");
        exit(1);
    }
    tmp->kind = is_RExprOpa;
    tmp->u.rexpropa_.opa_ = p1;
    return tmp;
}

/********************   LSom    ********************/

Opa make_LSom(Opa p1, Opa p2)
{
    Opa tmp = (Opa) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LSom!\n");
        exit(1);
    }
    tmp->kind = is_LSom;
    tmp->u.lsom_.opa_1 = p1;
    tmp->u.lsom_.opa_2 = p2;
    return tmp;
}

/********************   LSub    ********************/

Opa make_LSub(Opa p1, Opa p2)
{
    Opa tmp = (Opa) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LSub!\n");
        exit(1);
    }
    tmp->kind = is_LSub;
    tmp->u.lsub_.opa_1 = p1;
    tmp->u.lsub_.opa_2 = p2;
    return tmp;
}

/********************   LMul    ********************/

Opa make_LMul(Opa p1, Opa p2)
{
    Opa tmp = (Opa) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LMul!\n");
        exit(1);
    }
    tmp->kind = is_LMul;
    tmp->u.lmul_.opa_1 = p1;
    tmp->u.lmul_.opa_2 = p2;
    return tmp;
}

/********************   LDiv    ********************/

Opa make_LDiv(Opa p1, Opa p2)
{
    Opa tmp = (Opa) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LDiv!\n");
        exit(1);
    }
    tmp->kind = is_LDiv;
    tmp->u.ldiv_.opa_1 = p1;
    tmp->u.ldiv_.opa_2 = p2;
    return tmp;
}

/********************   Opa2Integer    ********************/

Opa make_Opa2Integer(Integer p1)
{
    Opa tmp = (Opa) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Opa2Integer!\n");
        exit(1);
    }
    tmp->kind = is_Opa2Integer;
    tmp->u.opa2integer_.integer_ = p1;
    return tmp;
}

/********************   Opa2Double    ********************/

Opa make_Opa2Double(Double p1)
{
    Opa tmp = (Opa) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Opa2Double!\n");
        exit(1);
    }
    tmp->kind = is_Opa2Double;
    tmp->u.opa2double_.double_ = p1;
    return tmp;
}

/********************   Opa2Ident    ********************/

Opa make_Opa2Ident(Ident p1)
{
    Opa tmp = (Opa) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Opa2Ident!\n");
        exit(1);
    }
    tmp->kind = is_Opa2Ident;
    tmp->u.opa2ident_.ident_ = p1;
    return tmp;
}

/********************   ExpressaoLogica1    ********************/

ExpressaoLogica make_ExpressaoLogica1(RExpr p1, OperadoresLogicos p2, RExpr p3)
{
    ExpressaoLogica tmp = (ExpressaoLogica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressaoLogica1!\n");
        exit(1);
    }
    tmp->kind = is_ExpressaoLogica1;
    tmp->u.expressaologica1_.rexpr_1 = p1;
    tmp->u.expressaologica1_.operadoreslogicos_ = p2;
    tmp->u.expressaologica1_.rexpr_2 = p3;
    return tmp;
}

/********************   ExpressaoLogica2    ********************/

ExpressaoLogica make_ExpressaoLogica2(RExpr p1, OperadoresLogicos p2, RExpr p3, ConectivosLogicos p4, ExpressaoLogica p5)
{
    ExpressaoLogica tmp = (ExpressaoLogica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressaoLogica2!\n");
        exit(1);
    }
    tmp->kind = is_ExpressaoLogica2;
    tmp->u.expressaologica2_.rexpr_1 = p1;
    tmp->u.expressaologica2_.operadoreslogicos_ = p2;
    tmp->u.expressaologica2_.rexpr_2 = p3;
    tmp->u.expressaologica2_.conectivoslogicos_ = p4;
    tmp->u.expressaologica2_.expressaologica_ = p5;
    return tmp;
}

/********************   IfIfStmt    ********************/

If make_IfIfStmt(IfStmt p1)
{
    If tmp = (If) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating IfIfStmt!\n");
        exit(1);
    }
    tmp->kind = is_IfIfStmt;
    tmp->u.ififstmt_.ifstmt_ = p1;
    return tmp;
}

/********************   If1    ********************/

If make_If1(IfStmt p1, ElseStmt p2)
{
    If tmp = (If) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating If1!\n");
        exit(1);
    }
    tmp->kind = is_If1;
    tmp->u.if1_.ifstmt_ = p1;
    tmp->u.if1_.elsestmt_ = p2;
    return tmp;
}

/********************   If2    ********************/

If make_If2(IfStmt p1, ElsIfStmt p2, ElseStmt p3)
{
    If tmp = (If) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating If2!\n");
        exit(1);
    }
    tmp->kind = is_If2;
    tmp->u.if2_.ifstmt_ = p1;
    tmp->u.if2_.elsifstmt_ = p2;
    tmp->u.if2_.elsestmt_ = p3;
    return tmp;
}

/********************   If_    ********************/

If make_If_()
{
    If tmp = (If) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating If_!\n");
        exit(1);
    }
    tmp->kind = is_If_;
    return tmp;
}

/********************   IfStmt1    ********************/

IfStmt make_IfStmt1(ExpressaoLogica p1, BlocoStmt p2)
{
    IfStmt tmp = (IfStmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating IfStmt1!\n");
        exit(1);
    }
    tmp->kind = is_IfStmt1;
    tmp->u.ifstmt1_.expressaologica_ = p1;
    tmp->u.ifstmt1_.blocostmt_ = p2;
    return tmp;
}

/********************   ElseStmt1    ********************/

ElseStmt make_ElseStmt1(BlocoStmt p1)
{
    ElseStmt tmp = (ElseStmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ElseStmt1!\n");
        exit(1);
    }
    tmp->kind = is_ElseStmt1;
    tmp->u.elsestmt1_.blocostmt_ = p1;
    return tmp;
}

/********************   ElsIfStmt1    ********************/

ElsIfStmt make_ElsIfStmt1(ExpressaoLogica p1, BlocoStmt p2)
{
    ElsIfStmt tmp = (ElsIfStmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ElsIfStmt1!\n");
        exit(1);
    }
    tmp->kind = is_ElsIfStmt1;
    tmp->u.elsifstmt1_.expressaologica_ = p1;
    tmp->u.elsifstmt1_.blocostmt_ = p2;
    return tmp;
}

/********************   While1    ********************/

While make_While1(ExpressaoLogica p1, BlocoStmt p2)
{
    While tmp = (While) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating While1!\n");
        exit(1);
    }
    tmp->kind = is_While1;
    tmp->u.while1_.expressaologica_ = p1;
    tmp->u.while1_.blocostmt_ = p2;
    return tmp;
}

/********************   For1    ********************/

For make_For1(Atribuicao p1, RExpr p2, BlocoStmt p3)
{
    For tmp = (For) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating For1!\n");
        exit(1);
    }
    tmp->kind = is_For1;
    tmp->u.for1_.atribuicao_ = p1;
    tmp->u.for1_.rexpr_ = p2;
    tmp->u.for1_.blocostmt_ = p3;
    return tmp;
}

/********************   CaseCaseStmt    ********************/

Case make_CaseCaseStmt(CaseStmt p1)
{
    Case tmp = (Case) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CaseCaseStmt!\n");
        exit(1);
    }
    tmp->kind = is_CaseCaseStmt;
    tmp->u.casecasestmt_.casestmt_ = p1;
    return tmp;
}

/********************   CaseStmt1    ********************/

CaseStmt make_CaseStmt1(Ident p1, BlocoStmt p2)
{
    CaseStmt tmp = (CaseStmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CaseStmt1!\n");
        exit(1);
    }
    tmp->kind = is_CaseStmt1;
    tmp->u.casestmt1_.ident_ = p1;
    tmp->u.casestmt1_.blocostmt_ = p2;
    return tmp;
}

/********************   CaseStmt2    ********************/

CaseStmt make_CaseStmt2(BlocoStmt p1)
{
    CaseStmt tmp = (CaseStmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CaseStmt2!\n");
        exit(1);
    }
    tmp->kind = is_CaseStmt2;
    tmp->u.casestmt2_.blocostmt_ = p1;
    return tmp;
}

/********************   Type_INTEGER    ********************/

Type make_Type_INTEGER()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Type_INTEGER!\n");
        exit(1);
    }
    tmp->kind = is_Type_INTEGER;
    return tmp;
}

/********************   Type_REAL    ********************/

Type make_Type_REAL()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Type_REAL!\n");
        exit(1);
    }
    tmp->kind = is_Type_REAL;
    return tmp;
}

/********************   Type_CHAR    ********************/

Type make_Type_CHAR()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Type_CHAR!\n");
        exit(1);
    }
    tmp->kind = is_Type_CHAR;
    return tmp;
}

/********************   Type_STRING    ********************/

Type make_Type_STRING()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Type_STRING!\n");
        exit(1);
    }
    tmp->kind = is_Type_STRING;
    return tmp;
}

/********************   OperadoresLogicos1    ********************/

OperadoresLogicos make_OperadoresLogicos1()
{
    OperadoresLogicos tmp = (OperadoresLogicos) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadoresLogicos1!\n");
        exit(1);
    }
    tmp->kind = is_OperadoresLogicos1;
    return tmp;
}

/********************   OperadoresLogicos2    ********************/

OperadoresLogicos make_OperadoresLogicos2()
{
    OperadoresLogicos tmp = (OperadoresLogicos) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadoresLogicos2!\n");
        exit(1);
    }
    tmp->kind = is_OperadoresLogicos2;
    return tmp;
}

/********************   OperadoresLogicos3    ********************/

OperadoresLogicos make_OperadoresLogicos3()
{
    OperadoresLogicos tmp = (OperadoresLogicos) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadoresLogicos3!\n");
        exit(1);
    }
    tmp->kind = is_OperadoresLogicos3;
    return tmp;
}

/********************   OperadoresLogicos4    ********************/

OperadoresLogicos make_OperadoresLogicos4()
{
    OperadoresLogicos tmp = (OperadoresLogicos) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadoresLogicos4!\n");
        exit(1);
    }
    tmp->kind = is_OperadoresLogicos4;
    return tmp;
}

/********************   OperadoresLogicos5    ********************/

OperadoresLogicos make_OperadoresLogicos5()
{
    OperadoresLogicos tmp = (OperadoresLogicos) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadoresLogicos5!\n");
        exit(1);
    }
    tmp->kind = is_OperadoresLogicos5;
    return tmp;
}

/********************   OperadoresLogicos6    ********************/

OperadoresLogicos make_OperadoresLogicos6()
{
    OperadoresLogicos tmp = (OperadoresLogicos) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadoresLogicos6!\n");
        exit(1);
    }
    tmp->kind = is_OperadoresLogicos6;
    return tmp;
}

/********************   ConectivosLogicos_AND    ********************/

ConectivosLogicos make_ConectivosLogicos_AND()
{
    ConectivosLogicos tmp = (ConectivosLogicos) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConectivosLogicos_AND!\n");
        exit(1);
    }
    tmp->kind = is_ConectivosLogicos_AND;
    return tmp;
}

/********************   ConectivosLogicos_OR    ********************/

ConectivosLogicos make_ConectivosLogicos_OR()
{
    ConectivosLogicos tmp = (ConectivosLogicos) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConectivosLogicos_OR!\n");
        exit(1);
    }
    tmp->kind = is_ConectivosLogicos_OR;
    return tmp;
}

/********************   ConectivosLogicos_NOT    ********************/

ConectivosLogicos make_ConectivosLogicos_NOT()
{
    ConectivosLogicos tmp = (ConectivosLogicos) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConectivosLogicos_NOT!\n");
        exit(1);
    }
    tmp->kind = is_ConectivosLogicos_NOT;
    return tmp;
}

/***************************   Cloning   ******************************/

Progr clone_Progr(Progr p)
{
  switch(p->kind)
  {
  case is_Program:
    return make_Program
      ( strdup(p->u.program_.ident_1)
      , clone_BlocoDec(p->u.program_.blocodec_)
      , clone_RegraStmt(p->u.program_.regrastmt_)
      , strdup(p->u.program_.ident_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Progr!\n");
    exit(1);
  }
}

BlocoDec clone_BlocoDec(BlocoDec p)
{
  switch(p->kind)
  {
  case is_BlocoDec1:
    return make_BlocoDec1
      ( clone_BlocoConstante(p->u.blocodec1_.blococonstante_)
      , clone_BlocoDec(p->u.blocodec1_.blocodec_)
      );

  case is_BlocoDec2:
    return make_BlocoDec2
      ( clone_BlocoVar(p->u.blocodec2_.blocovar_)
      , clone_BlocoDec(p->u.blocodec2_.blocodec_)
      );

  case is_BlocoDec3:
    return make_BlocoDec3
      ( clone_BlocoType(p->u.blocodec3_.blocotype_)
      , clone_BlocoDec(p->u.blocodec3_.blocodec_)
      );

  case is_BlocoDec_:
    return make_BlocoDec_ ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning BlocoDec!\n");
    exit(1);
  }
}

BlocoConstante clone_BlocoConstante(BlocoConstante p)
{
  switch(p->kind)
  {
  case is_BlocoConstante1:
    return make_BlocoConstante1 (clone_RegraConstante(p->u.blococonstante1_.regraconstante_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning BlocoConstante!\n");
    exit(1);
  }
}

RegraConstante clone_RegraConstante(RegraConstante p)
{
  switch(p->kind)
  {
  case is_RegraConstante1:
    return make_RegraConstante1
      ( strdup(p->u.regraconstante1_.ident_)
      , clone_Type(p->u.regraconstante1_.type_)
      , clone_Valor(p->u.regraconstante1_.valor_)
      );

  case is_RegraConstante2:
    return make_RegraConstante2
      ( strdup(p->u.regraconstante2_.ident_)
      , clone_Type(p->u.regraconstante2_.type_)
      , clone_Valor(p->u.regraconstante2_.valor_)
      , clone_RegraConstante(p->u.regraconstante2_.regraconstante_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraConstante!\n");
    exit(1);
  }
}

RegraDec clone_RegraDec(RegraDec p)
{
  switch(p->kind)
  {
  case is_RegraDec1:
    return make_RegraDec1
      ( strdup(p->u.regradec1_.ident_)
      , clone_Type(p->u.regradec1_.type_)
      );

  case is_RegraDec2:
    return make_RegraDec2
      ( strdup(p->u.regradec2_.ident_)
      , clone_Type(p->u.regradec2_.type_)
      , clone_RegraDec(p->u.regradec2_.regradec_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraDec!\n");
    exit(1);
  }
}

BlocoVar clone_BlocoVar(BlocoVar p)
{
  switch(p->kind)
  {
  case is_BlocoVar1:
    return make_BlocoVar1 (clone_RegraDecVar(p->u.blocovar1_.regradecvar_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning BlocoVar!\n");
    exit(1);
  }
}

RegraDecVar clone_RegraDecVar(RegraDecVar p)
{
  switch(p->kind)
  {
  case is_RegraDecVar1:
    return make_RegraDecVar1 (clone_RegraDec(p->u.regradecvar1_.regradec_));

  case is_RegraDecVar2:
    return make_RegraDecVar2
      ( clone_RegraDec(p->u.regradecvar2_.regradec_)
      , clone_RegraDecVar(p->u.regradecvar2_.regradecvar_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraDecVar!\n");
    exit(1);
  }
}

BlocoType clone_BlocoType(BlocoType p)
{
  switch(p->kind)
  {
  case is_BlocoType1:
    return make_BlocoType1 (clone_RegraType(p->u.blocotype1_.regratype_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning BlocoType!\n");
    exit(1);
  }
}

RegraType clone_RegraType(RegraType p)
{
  switch(p->kind)
  {
  case is_RegraTypeRegraDecVetor:
    return make_RegraTypeRegraDecVetor (clone_RegraDecVetor(p->u.regratyperegradecvetor_.regradecvetor_));

  case is_RegraType1:
    return make_RegraType1
      ( clone_RegraDecVetor(p->u.regratype1_.regradecvetor_)
      , clone_RegraType(p->u.regratype1_.regratype_)
      );

  case is_RegraTypeRegraDecStruct:
    return make_RegraTypeRegraDecStruct (clone_RegraDecStruct(p->u.regratyperegradecstruct_.regradecstruct_));

  case is_RegraType2:
    return make_RegraType2
      ( clone_RegraDecStruct(p->u.regratype2_.regradecstruct_)
      , clone_RegraType(p->u.regratype2_.regratype_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraType!\n");
    exit(1);
  }
}

RegraDecVetor clone_RegraDecVetor(RegraDecVetor p)
{
  switch(p->kind)
  {
  case is_RegraDecVetor1:
    return make_RegraDecVetor1
      ( strdup(p->u.regradecvetor1_.ident_)
      , p->u.regradecvetor1_.integer_
      , clone_Type(p->u.regradecvetor1_.type_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraDecVetor!\n");
    exit(1);
  }
}

RegraDecStruct clone_RegraDecStruct(RegraDecStruct p)
{
  switch(p->kind)
  {
  case is_RegraDecStruct1:
    return make_RegraDecStruct1
      ( strdup(p->u.regradecstruct1_.ident_)
      , clone_RegraDec(p->u.regradecstruct1_.regradec_)
      );

  case is_RegraDecStruct2:
    return make_RegraDecStruct2
      ( strdup(p->u.regradecstruct2_.ident_)
      , clone_RegraDec(p->u.regradecstruct2_.regradec_)
      , clone_RegraDecStruct(p->u.regradecstruct2_.regradecstruct_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraDecStruct!\n");
    exit(1);
  }
}

BlocoStmt clone_BlocoStmt(BlocoStmt p)
{
  switch(p->kind)
  {
  case is_BlocoStmt1:
    return make_BlocoStmt1 (clone_RegraStmt(p->u.blocostmt1_.regrastmt_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning BlocoStmt!\n");
    exit(1);
  }
}

RegraStmt clone_RegraStmt(RegraStmt p)
{
  switch(p->kind)
  {
  case is_RegraStmtStmt:
    return make_RegraStmtStmt (clone_Stmt(p->u.regrastmtstmt_.stmt_));

  case is_RegraStmt1:
    return make_RegraStmt1
      ( clone_Stmt(p->u.regrastmt1_.stmt_)
      , clone_RegraStmt(p->u.regrastmt1_.regrastmt_)
      );

  case is_RegraStmt_:
    return make_RegraStmt_ ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraStmt!\n");
    exit(1);
  }
}

Stmt clone_Stmt(Stmt p)
{
  switch(p->kind)
  {
  case is_Stmt1:
    return make_Stmt1 (clone_Atribuicao(p->u.stmt1_.atribuicao_));

  case is_Stmt2:
    return make_Stmt2 (clone_Opa(p->u.stmt2_.opa_));

  case is_Stmt3:
    return make_Stmt3 (clone_If(p->u.stmt3_.if_));

  case is_Stmt4:
    return make_Stmt4 (clone_While(p->u.stmt4_.while_));

  case is_Stmt5:
    return make_Stmt5 (clone_For(p->u.stmt5_.for_));

  case is_Stmt6:
    return make_Stmt6 (clone_Case(p->u.stmt6_.case_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Stmt!\n");
    exit(1);
  }
}

Atribuicao clone_Atribuicao(Atribuicao p)
{
  switch(p->kind)
  {
  case is_Atribuicao1:
    return make_Atribuicao1
      ( strdup(p->u.atribuicao1_.ident_)
      , clone_RExpr(p->u.atribuicao1_.rexpr_)
      );

  case is_AtribuicaoAtribuicaoVetor:
    return make_AtribuicaoAtribuicaoVetor (clone_AtribuicaoVetor(p->u.atribuicaoatribuicaovetor_.atribuicaovetor_));

  case is_AtribuicaoAtribuicaoStruct:
    return make_AtribuicaoAtribuicaoStruct (clone_AtribuicaoStruct(p->u.atribuicaoatribuicaostruct_.atribuicaostruct_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Atribuicao!\n");
    exit(1);
  }
}

AtribuicaoVetor clone_AtribuicaoVetor(AtribuicaoVetor p)
{
  switch(p->kind)
  {
  case is_AtribuicaoVetor1:
    return make_AtribuicaoVetor1
      ( strdup(p->u.atribuicaovetor1_.ident_)
      , p->u.atribuicaovetor1_.integer_
      , clone_Valor(p->u.atribuicaovetor1_.valor_)
      );

  case is_AtribuicaoVetor2:
    return make_AtribuicaoVetor2
      ( strdup(p->u.atribuicaovetor2_.ident_1)
      , p->u.atribuicaovetor2_.integer_
      , strdup(p->u.atribuicaovetor2_.ident_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning AtribuicaoVetor!\n");
    exit(1);
  }
}

AtribuicaoStruct clone_AtribuicaoStruct(AtribuicaoStruct p)
{
  switch(p->kind)
  {
  case is_AtribuicaoStruct1:
    return make_AtribuicaoStruct1
      ( strdup(p->u.atribuicaostruct1_.ident_1)
      , strdup(p->u.atribuicaostruct1_.ident_2)
      , clone_Valor(p->u.atribuicaostruct1_.valor_)
      );

  case is_AtribuicaoStruct2:
    return make_AtribuicaoStruct2
      ( strdup(p->u.atribuicaostruct2_.ident_1)
      , strdup(p->u.atribuicaostruct2_.ident_2)
      , strdup(p->u.atribuicaostruct2_.ident_3)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning AtribuicaoStruct!\n");
    exit(1);
  }
}

Valor clone_Valor(Valor p)
{
  switch(p->kind)
  {
  case is_ValorString:
    return make_ValorString (strdup(p->u.valorstring_.string_));

  case is_ValorChar:
    return make_ValorChar (p->u.valorchar_.char_);

  case is_ValorDouble:
    return make_ValorDouble (p->u.valordouble_.double_);

  case is_ValorInteger:
    return make_ValorInteger (p->u.valorinteger_.integer_);

  default:
    fprintf(stderr, "Error: bad kind field when cloning Valor!\n");
    exit(1);
  }
}

RExpr clone_RExpr(RExpr p)
{
  switch(p->kind)
  {
  case is_RExprValor:
    return make_RExprValor (clone_Valor(p->u.rexprvalor_.valor_));

  case is_RExprIdent:
    return make_RExprIdent (strdup(p->u.rexprident_.ident_));

  case is_RExprOpa:
    return make_RExprOpa (clone_Opa(p->u.rexpropa_.opa_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning RExpr!\n");
    exit(1);
  }
}

Opa clone_Opa(Opa p)
{
  switch(p->kind)
  {
  case is_LSom:
    return make_LSom
      ( clone_Opa(p->u.lsom_.opa_1)
      , clone_Opa(p->u.lsom_.opa_2)
      );

  case is_LSub:
    return make_LSub
      ( clone_Opa(p->u.lsub_.opa_1)
      , clone_Opa(p->u.lsub_.opa_2)
      );

  case is_LMul:
    return make_LMul
      ( clone_Opa(p->u.lmul_.opa_1)
      , clone_Opa(p->u.lmul_.opa_2)
      );

  case is_LDiv:
    return make_LDiv
      ( clone_Opa(p->u.ldiv_.opa_1)
      , clone_Opa(p->u.ldiv_.opa_2)
      );

  case is_Opa2Integer:
    return make_Opa2Integer (p->u.opa2integer_.integer_);

  case is_Opa2Double:
    return make_Opa2Double (p->u.opa2double_.double_);

  case is_Opa2Ident:
    return make_Opa2Ident (strdup(p->u.opa2ident_.ident_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Opa!\n");
    exit(1);
  }
}

ExpressaoLogica clone_ExpressaoLogica(ExpressaoLogica p)
{
  switch(p->kind)
  {
  case is_ExpressaoLogica1:
    return make_ExpressaoLogica1
      ( clone_RExpr(p->u.expressaologica1_.rexpr_1)
      , clone_OperadoresLogicos(p->u.expressaologica1_.operadoreslogicos_)
      , clone_RExpr(p->u.expressaologica1_.rexpr_2)
      );

  case is_ExpressaoLogica2:
    return make_ExpressaoLogica2
      ( clone_RExpr(p->u.expressaologica2_.rexpr_1)
      , clone_OperadoresLogicos(p->u.expressaologica2_.operadoreslogicos_)
      , clone_RExpr(p->u.expressaologica2_.rexpr_2)
      , clone_ConectivosLogicos(p->u.expressaologica2_.conectivoslogicos_)
      , clone_ExpressaoLogica(p->u.expressaologica2_.expressaologica_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ExpressaoLogica!\n");
    exit(1);
  }
}

If clone_If(If p)
{
  switch(p->kind)
  {
  case is_IfIfStmt:
    return make_IfIfStmt (clone_IfStmt(p->u.ififstmt_.ifstmt_));

  case is_If1:
    return make_If1
      ( clone_IfStmt(p->u.if1_.ifstmt_)
      , clone_ElseStmt(p->u.if1_.elsestmt_)
      );

  case is_If2:
    return make_If2
      ( clone_IfStmt(p->u.if2_.ifstmt_)
      , clone_ElsIfStmt(p->u.if2_.elsifstmt_)
      , clone_ElseStmt(p->u.if2_.elsestmt_)
      );

  case is_If_:
    return make_If_ ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning If!\n");
    exit(1);
  }
}

IfStmt clone_IfStmt(IfStmt p)
{
  switch(p->kind)
  {
  case is_IfStmt1:
    return make_IfStmt1
      ( clone_ExpressaoLogica(p->u.ifstmt1_.expressaologica_)
      , clone_BlocoStmt(p->u.ifstmt1_.blocostmt_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning IfStmt!\n");
    exit(1);
  }
}

ElseStmt clone_ElseStmt(ElseStmt p)
{
  switch(p->kind)
  {
  case is_ElseStmt1:
    return make_ElseStmt1 (clone_BlocoStmt(p->u.elsestmt1_.blocostmt_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning ElseStmt!\n");
    exit(1);
  }
}

ElsIfStmt clone_ElsIfStmt(ElsIfStmt p)
{
  switch(p->kind)
  {
  case is_ElsIfStmt1:
    return make_ElsIfStmt1
      ( clone_ExpressaoLogica(p->u.elsifstmt1_.expressaologica_)
      , clone_BlocoStmt(p->u.elsifstmt1_.blocostmt_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ElsIfStmt!\n");
    exit(1);
  }
}

While clone_While(While p)
{
  switch(p->kind)
  {
  case is_While1:
    return make_While1
      ( clone_ExpressaoLogica(p->u.while1_.expressaologica_)
      , clone_BlocoStmt(p->u.while1_.blocostmt_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning While!\n");
    exit(1);
  }
}

For clone_For(For p)
{
  switch(p->kind)
  {
  case is_For1:
    return make_For1
      ( clone_Atribuicao(p->u.for1_.atribuicao_)
      , clone_RExpr(p->u.for1_.rexpr_)
      , clone_BlocoStmt(p->u.for1_.blocostmt_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning For!\n");
    exit(1);
  }
}

Case clone_Case(Case p)
{
  switch(p->kind)
  {
  case is_CaseCaseStmt:
    return make_CaseCaseStmt (clone_CaseStmt(p->u.casecasestmt_.casestmt_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Case!\n");
    exit(1);
  }
}

CaseStmt clone_CaseStmt(CaseStmt p)
{
  switch(p->kind)
  {
  case is_CaseStmt1:
    return make_CaseStmt1
      ( strdup(p->u.casestmt1_.ident_)
      , clone_BlocoStmt(p->u.casestmt1_.blocostmt_)
      );

  case is_CaseStmt2:
    return make_CaseStmt2 (clone_BlocoStmt(p->u.casestmt2_.blocostmt_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning CaseStmt!\n");
    exit(1);
  }
}

Type clone_Type(Type p)
{
  switch(p->kind)
  {
  case is_Type_INTEGER:
    return make_Type_INTEGER ();

  case is_Type_REAL:
    return make_Type_REAL ();

  case is_Type_CHAR:
    return make_Type_CHAR ();

  case is_Type_STRING:
    return make_Type_STRING ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Type!\n");
    exit(1);
  }
}

OperadoresLogicos clone_OperadoresLogicos(OperadoresLogicos p)
{
  switch(p->kind)
  {
  case is_OperadoresLogicos1:
    return make_OperadoresLogicos1 ();

  case is_OperadoresLogicos2:
    return make_OperadoresLogicos2 ();

  case is_OperadoresLogicos3:
    return make_OperadoresLogicos3 ();

  case is_OperadoresLogicos4:
    return make_OperadoresLogicos4 ();

  case is_OperadoresLogicos5:
    return make_OperadoresLogicos5 ();

  case is_OperadoresLogicos6:
    return make_OperadoresLogicos6 ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning OperadoresLogicos!\n");
    exit(1);
  }
}

ConectivosLogicos clone_ConectivosLogicos(ConectivosLogicos p)
{
  switch(p->kind)
  {
  case is_ConectivosLogicos_AND:
    return make_ConectivosLogicos_AND ();

  case is_ConectivosLogicos_OR:
    return make_ConectivosLogicos_OR ();

  case is_ConectivosLogicos_NOT:
    return make_ConectivosLogicos_NOT ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning ConectivosLogicos!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Progr(Progr p)
{
  switch(p->kind)
  {
  case is_Program:
    free(p->u.program_.ident_1);
    free_BlocoDec(p->u.program_.blocodec_);
    free_RegraStmt(p->u.program_.regrastmt_);
    free(p->u.program_.ident_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Progr!\n");
    exit(1);
  }
  free(p);
}

void free_BlocoDec(BlocoDec p)
{
  switch(p->kind)
  {
  case is_BlocoDec1:
    free_BlocoConstante(p->u.blocodec1_.blococonstante_);
    free_BlocoDec(p->u.blocodec1_.blocodec_);
    break;

  case is_BlocoDec2:
    free_BlocoVar(p->u.blocodec2_.blocovar_);
    free_BlocoDec(p->u.blocodec2_.blocodec_);
    break;

  case is_BlocoDec3:
    free_BlocoType(p->u.blocodec3_.blocotype_);
    free_BlocoDec(p->u.blocodec3_.blocodec_);
    break;

  case is_BlocoDec_:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing BlocoDec!\n");
    exit(1);
  }
  free(p);
}

void free_BlocoConstante(BlocoConstante p)
{
  switch(p->kind)
  {
  case is_BlocoConstante1:
    free_RegraConstante(p->u.blococonstante1_.regraconstante_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing BlocoConstante!\n");
    exit(1);
  }
  free(p);
}

void free_RegraConstante(RegraConstante p)
{
  switch(p->kind)
  {
  case is_RegraConstante1:
    free(p->u.regraconstante1_.ident_);
    free_Type(p->u.regraconstante1_.type_);
    free_Valor(p->u.regraconstante1_.valor_);
    break;

  case is_RegraConstante2:
    free(p->u.regraconstante2_.ident_);
    free_Type(p->u.regraconstante2_.type_);
    free_Valor(p->u.regraconstante2_.valor_);
    free_RegraConstante(p->u.regraconstante2_.regraconstante_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraConstante!\n");
    exit(1);
  }
  free(p);
}

void free_RegraDec(RegraDec p)
{
  switch(p->kind)
  {
  case is_RegraDec1:
    free(p->u.regradec1_.ident_);
    free_Type(p->u.regradec1_.type_);
    break;

  case is_RegraDec2:
    free(p->u.regradec2_.ident_);
    free_Type(p->u.regradec2_.type_);
    free_RegraDec(p->u.regradec2_.regradec_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraDec!\n");
    exit(1);
  }
  free(p);
}

void free_BlocoVar(BlocoVar p)
{
  switch(p->kind)
  {
  case is_BlocoVar1:
    free_RegraDecVar(p->u.blocovar1_.regradecvar_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing BlocoVar!\n");
    exit(1);
  }
  free(p);
}

void free_RegraDecVar(RegraDecVar p)
{
  switch(p->kind)
  {
  case is_RegraDecVar1:
    free_RegraDec(p->u.regradecvar1_.regradec_);
    break;

  case is_RegraDecVar2:
    free_RegraDec(p->u.regradecvar2_.regradec_);
    free_RegraDecVar(p->u.regradecvar2_.regradecvar_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraDecVar!\n");
    exit(1);
  }
  free(p);
}

void free_BlocoType(BlocoType p)
{
  switch(p->kind)
  {
  case is_BlocoType1:
    free_RegraType(p->u.blocotype1_.regratype_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing BlocoType!\n");
    exit(1);
  }
  free(p);
}

void free_RegraType(RegraType p)
{
  switch(p->kind)
  {
  case is_RegraTypeRegraDecVetor:
    free_RegraDecVetor(p->u.regratyperegradecvetor_.regradecvetor_);
    break;

  case is_RegraType1:
    free_RegraDecVetor(p->u.regratype1_.regradecvetor_);
    free_RegraType(p->u.regratype1_.regratype_);
    break;

  case is_RegraTypeRegraDecStruct:
    free_RegraDecStruct(p->u.regratyperegradecstruct_.regradecstruct_);
    break;

  case is_RegraType2:
    free_RegraDecStruct(p->u.regratype2_.regradecstruct_);
    free_RegraType(p->u.regratype2_.regratype_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraType!\n");
    exit(1);
  }
  free(p);
}

void free_RegraDecVetor(RegraDecVetor p)
{
  switch(p->kind)
  {
  case is_RegraDecVetor1:
    free(p->u.regradecvetor1_.ident_);
    free_Type(p->u.regradecvetor1_.type_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraDecVetor!\n");
    exit(1);
  }
  free(p);
}

void free_RegraDecStruct(RegraDecStruct p)
{
  switch(p->kind)
  {
  case is_RegraDecStruct1:
    free(p->u.regradecstruct1_.ident_);
    free_RegraDec(p->u.regradecstruct1_.regradec_);
    break;

  case is_RegraDecStruct2:
    free(p->u.regradecstruct2_.ident_);
    free_RegraDec(p->u.regradecstruct2_.regradec_);
    free_RegraDecStruct(p->u.regradecstruct2_.regradecstruct_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraDecStruct!\n");
    exit(1);
  }
  free(p);
}

void free_BlocoStmt(BlocoStmt p)
{
  switch(p->kind)
  {
  case is_BlocoStmt1:
    free_RegraStmt(p->u.blocostmt1_.regrastmt_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing BlocoStmt!\n");
    exit(1);
  }
  free(p);
}

void free_RegraStmt(RegraStmt p)
{
  switch(p->kind)
  {
  case is_RegraStmtStmt:
    free_Stmt(p->u.regrastmtstmt_.stmt_);
    break;

  case is_RegraStmt1:
    free_Stmt(p->u.regrastmt1_.stmt_);
    free_RegraStmt(p->u.regrastmt1_.regrastmt_);
    break;

  case is_RegraStmt_:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraStmt!\n");
    exit(1);
  }
  free(p);
}

void free_Stmt(Stmt p)
{
  switch(p->kind)
  {
  case is_Stmt1:
    free_Atribuicao(p->u.stmt1_.atribuicao_);
    break;

  case is_Stmt2:
    free_Opa(p->u.stmt2_.opa_);
    break;

  case is_Stmt3:
    free_If(p->u.stmt3_.if_);
    break;

  case is_Stmt4:
    free_While(p->u.stmt4_.while_);
    break;

  case is_Stmt5:
    free_For(p->u.stmt5_.for_);
    break;

  case is_Stmt6:
    free_Case(p->u.stmt6_.case_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Stmt!\n");
    exit(1);
  }
  free(p);
}

void free_Atribuicao(Atribuicao p)
{
  switch(p->kind)
  {
  case is_Atribuicao1:
    free(p->u.atribuicao1_.ident_);
    free_RExpr(p->u.atribuicao1_.rexpr_);
    break;

  case is_AtribuicaoAtribuicaoVetor:
    free_AtribuicaoVetor(p->u.atribuicaoatribuicaovetor_.atribuicaovetor_);
    break;

  case is_AtribuicaoAtribuicaoStruct:
    free_AtribuicaoStruct(p->u.atribuicaoatribuicaostruct_.atribuicaostruct_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Atribuicao!\n");
    exit(1);
  }
  free(p);
}

void free_AtribuicaoVetor(AtribuicaoVetor p)
{
  switch(p->kind)
  {
  case is_AtribuicaoVetor1:
    free(p->u.atribuicaovetor1_.ident_);
    free_Valor(p->u.atribuicaovetor1_.valor_);
    break;

  case is_AtribuicaoVetor2:
    free(p->u.atribuicaovetor2_.ident_1);
    free(p->u.atribuicaovetor2_.ident_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing AtribuicaoVetor!\n");
    exit(1);
  }
  free(p);
}

void free_AtribuicaoStruct(AtribuicaoStruct p)
{
  switch(p->kind)
  {
  case is_AtribuicaoStruct1:
    free(p->u.atribuicaostruct1_.ident_1);
    free(p->u.atribuicaostruct1_.ident_2);
    free_Valor(p->u.atribuicaostruct1_.valor_);
    break;

  case is_AtribuicaoStruct2:
    free(p->u.atribuicaostruct2_.ident_1);
    free(p->u.atribuicaostruct2_.ident_2);
    free(p->u.atribuicaostruct2_.ident_3);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing AtribuicaoStruct!\n");
    exit(1);
  }
  free(p);
}

void free_Valor(Valor p)
{
  switch(p->kind)
  {
  case is_ValorString:
    free(p->u.valorstring_.string_);
    break;

  case is_ValorChar:
    break;

  case is_ValorDouble:
    break;

  case is_ValorInteger:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Valor!\n");
    exit(1);
  }
  free(p);
}

void free_RExpr(RExpr p)
{
  switch(p->kind)
  {
  case is_RExprValor:
    free_Valor(p->u.rexprvalor_.valor_);
    break;

  case is_RExprIdent:
    free(p->u.rexprident_.ident_);
    break;

  case is_RExprOpa:
    free_Opa(p->u.rexpropa_.opa_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RExpr!\n");
    exit(1);
  }
  free(p);
}

void free_Opa(Opa p)
{
  switch(p->kind)
  {
  case is_LSom:
    free_Opa(p->u.lsom_.opa_1);
    free_Opa(p->u.lsom_.opa_2);
    break;

  case is_LSub:
    free_Opa(p->u.lsub_.opa_1);
    free_Opa(p->u.lsub_.opa_2);
    break;

  case is_LMul:
    free_Opa(p->u.lmul_.opa_1);
    free_Opa(p->u.lmul_.opa_2);
    break;

  case is_LDiv:
    free_Opa(p->u.ldiv_.opa_1);
    free_Opa(p->u.ldiv_.opa_2);
    break;

  case is_Opa2Integer:
    break;

  case is_Opa2Double:
    break;

  case is_Opa2Ident:
    free(p->u.opa2ident_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Opa!\n");
    exit(1);
  }
  free(p);
}

void free_ExpressaoLogica(ExpressaoLogica p)
{
  switch(p->kind)
  {
  case is_ExpressaoLogica1:
    free_RExpr(p->u.expressaologica1_.rexpr_1);
    free_OperadoresLogicos(p->u.expressaologica1_.operadoreslogicos_);
    free_RExpr(p->u.expressaologica1_.rexpr_2);
    break;

  case is_ExpressaoLogica2:
    free_RExpr(p->u.expressaologica2_.rexpr_1);
    free_OperadoresLogicos(p->u.expressaologica2_.operadoreslogicos_);
    free_RExpr(p->u.expressaologica2_.rexpr_2);
    free_ConectivosLogicos(p->u.expressaologica2_.conectivoslogicos_);
    free_ExpressaoLogica(p->u.expressaologica2_.expressaologica_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ExpressaoLogica!\n");
    exit(1);
  }
  free(p);
}

void free_If(If p)
{
  switch(p->kind)
  {
  case is_IfIfStmt:
    free_IfStmt(p->u.ififstmt_.ifstmt_);
    break;

  case is_If1:
    free_IfStmt(p->u.if1_.ifstmt_);
    free_ElseStmt(p->u.if1_.elsestmt_);
    break;

  case is_If2:
    free_IfStmt(p->u.if2_.ifstmt_);
    free_ElsIfStmt(p->u.if2_.elsifstmt_);
    free_ElseStmt(p->u.if2_.elsestmt_);
    break;

  case is_If_:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing If!\n");
    exit(1);
  }
  free(p);
}

void free_IfStmt(IfStmt p)
{
  switch(p->kind)
  {
  case is_IfStmt1:
    free_ExpressaoLogica(p->u.ifstmt1_.expressaologica_);
    free_BlocoStmt(p->u.ifstmt1_.blocostmt_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing IfStmt!\n");
    exit(1);
  }
  free(p);
}

void free_ElseStmt(ElseStmt p)
{
  switch(p->kind)
  {
  case is_ElseStmt1:
    free_BlocoStmt(p->u.elsestmt1_.blocostmt_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ElseStmt!\n");
    exit(1);
  }
  free(p);
}

void free_ElsIfStmt(ElsIfStmt p)
{
  switch(p->kind)
  {
  case is_ElsIfStmt1:
    free_ExpressaoLogica(p->u.elsifstmt1_.expressaologica_);
    free_BlocoStmt(p->u.elsifstmt1_.blocostmt_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ElsIfStmt!\n");
    exit(1);
  }
  free(p);
}

void free_While(While p)
{
  switch(p->kind)
  {
  case is_While1:
    free_ExpressaoLogica(p->u.while1_.expressaologica_);
    free_BlocoStmt(p->u.while1_.blocostmt_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing While!\n");
    exit(1);
  }
  free(p);
}

void free_For(For p)
{
  switch(p->kind)
  {
  case is_For1:
    free_Atribuicao(p->u.for1_.atribuicao_);
    free_RExpr(p->u.for1_.rexpr_);
    free_BlocoStmt(p->u.for1_.blocostmt_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing For!\n");
    exit(1);
  }
  free(p);
}

void free_Case(Case p)
{
  switch(p->kind)
  {
  case is_CaseCaseStmt:
    free_CaseStmt(p->u.casecasestmt_.casestmt_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Case!\n");
    exit(1);
  }
  free(p);
}

void free_CaseStmt(CaseStmt p)
{
  switch(p->kind)
  {
  case is_CaseStmt1:
    free(p->u.casestmt1_.ident_);
    free_BlocoStmt(p->u.casestmt1_.blocostmt_);
    break;

  case is_CaseStmt2:
    free_BlocoStmt(p->u.casestmt2_.blocostmt_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing CaseStmt!\n");
    exit(1);
  }
  free(p);
}

void free_Type(Type p)
{
  switch(p->kind)
  {
  case is_Type_INTEGER:
    break;

  case is_Type_REAL:
    break;

  case is_Type_CHAR:
    break;

  case is_Type_STRING:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Type!\n");
    exit(1);
  }
  free(p);
}

void free_OperadoresLogicos(OperadoresLogicos p)
{
  switch(p->kind)
  {
  case is_OperadoresLogicos1:
    break;

  case is_OperadoresLogicos2:
    break;

  case is_OperadoresLogicos3:
    break;

  case is_OperadoresLogicos4:
    break;

  case is_OperadoresLogicos5:
    break;

  case is_OperadoresLogicos6:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OperadoresLogicos!\n");
    exit(1);
  }
  free(p);
}

void free_ConectivosLogicos(ConectivosLogicos p)
{
  switch(p->kind)
  {
  case is_ConectivosLogicos_AND:
    break;

  case is_ConectivosLogicos_OR:
    break;

  case is_ConectivosLogicos_NOT:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ConectivosLogicos!\n");
    exit(1);
  }
  free(p);
}

